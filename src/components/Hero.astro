---
import OptimizedImage from './OptimizedImage.astro';

// Importar todos los archivos YAML de la carpeta hero
const heroFiles = import.meta.glob('../data/hero/*.yml', { eager: true });
const heroSlides = Object.values(heroFiles).map((file: any) => file.default || file);
---

<!-- Hero sube detrÃ¡s del navbar transparente -->
<div class="relative group w-full -mt-16">
    <!-- Slider Container -->
    <div
        class="carousel w-full h-[70vh] lg:h-auto lg:aspect-21/9 overflow-x-auto snap-x snap-mandatory scroll-smooth no-scrollbar"
        id="hero-slider"
    >
        {
            heroSlides.map((slide: any, index: number) => (
                <div
                    id={`slide${index}`}
                    class="carousel-item relative w-full h-full snap-center"
                >
                    <a href={slide.link} class="block w-full h-full relative group/slide overflow-hidden">
                        <!-- Background Image -->
                        <OptimizedImage
                            src={slide.image}
                            alt={slide.title}
                            width={1920}
                            height={820}
                            loading={index === 0 ? "eager" : "lazy"}
                            fetchpriority={index === 0 ? "high" : "auto"}
                            class="absolute inset-0 w-full h-full object-cover scale-110 transition-transform duration-100 ease-out will-change-transform"
                        />
                        
                        <!-- Gradient Overlay -->
                        <div class="absolute inset-0 bg-gradient-to-t from-black/90 via-black/40 to-transparent pointer-events-none"></div>

                        <!-- Content -->
                        <div class="absolute bottom-0 left-0 w-full p-6 md:p-12 lg:p-16 flex flex-col justify-end items-start text-left pointer-events-none">
                            <div class="max-w-3xl animate-on-scroll">
                                <h1 class="text-3xl md:text-5xl lg:text-6xl font-bold text-white mb-4 drop-shadow-lg leading-tight">
                                    {slide.title}
                                </h1>
                                <p class="text-base md:text-lg lg:text-xl text-gray-200 mb-6 max-w-2xl leading-relaxed drop-shadow-md">
                                    {slide.description}
                                </p>
                                <span class="btn btn-primary btn-md lg:btn-lg rounded-full px-8 shadow-lg pointer-events-auto">
                                    {slide.buttonText}
                                </span>
                            </div>
                        </div>
                    </a>
                </div>
            ))
        }
    </div>

    <!-- Navigation Dots -->
    <div
        class="absolute flex justify-center gap-3 bottom-6 left-0 right-0 z-20"
    >
        {
            heroSlides.map((_: any, index: number) => (
                <button
                    class="w-3 h-3 rounded-full transition-all duration-300 bg-white/50 hover:bg-white hover:scale-125 focus:outline-none"
                    aria-label={`Go to slide ${index + 1}`}
                    data-index={index}
                />
            ))
        }
    </div>

    <!-- Arrows (Visible on hover on desktop) -->
    <div
        class="absolute flex justify-between transform -translate-y-1/2 left-4 right-4 top-1/2 opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none"
    >
        <button
            id="prev-slide"
            class="btn btn-circle btn-ghost bg-black/20 hover:bg-black/40 text-white border-none backdrop-blur-sm pointer-events-auto"
            aria-label="Diapositiva anterior"
        >
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-6 h-6" aria-hidden="true">
                <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
            </svg>
        </button>
        <button
            id="next-slide"
            class="btn btn-circle btn-ghost bg-black/20 hover:bg-black/40 text-white border-none backdrop-blur-sm pointer-events-auto"
            aria-label="Siguiente diapositiva"
        >
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-6 h-6" aria-hidden="true">
                <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" />
            </svg>
        </button>
    </div>
</div>

<style>
    /* Hide scrollbar for Chrome, Safari and Opera */
    .no-scrollbar::-webkit-scrollbar {
        display: none;
    }
    /* Hide scrollbar for IE, Edge and Firefox */
    .no-scrollbar {
        -ms-overflow-style: none; /* IE and Edge */
        scrollbar-width: none; /* Firefox */
    }
</style>

<script>
    const slider = document.getElementById("hero-slider");
    const slides = document.querySelectorAll(".carousel-item");
    const dots = document.querySelectorAll("[data-index]");
    const prevBtn = document.getElementById("prev-slide");
    const nextBtn = document.getElementById("next-slide");
    const totalSlides = slides.length;
    let currentIndex = 0;
    let intervalId: any;
    let cachedSliderWidth: number | null = null;

    // Cache slider width to avoid repeated layout reads
    const updateSliderWidth = () => {
        if (slider) {
            cachedSliderWidth = slider.clientWidth;
        }
    };

    // Initial width calculation
    updateSliderWidth();

    // Update on resize (debounced)
    let widthResizeTimeout: any;
    window.addEventListener("resize", () => {
        clearTimeout(widthResizeTimeout);
        widthResizeTimeout = setTimeout(updateSliderWidth, 100);
    }, { passive: true });

    // Function to scroll to a specific slide
    const scrollToSlide = (index: number) => {
        if (!slider || cachedSliderWidth === null) return;

        // Handle wrapping
        if (index < 0) index = totalSlides - 1;
        if (index >= totalSlides) index = 0;

        currentIndex = index;

        // Use cached width to avoid layout read
        const scrollAmount = cachedSliderWidth * currentIndex;
        slider.scrollTo({
            left: scrollAmount,
            behavior: "smooth",
        });

        // Batch DOM writes in next frame
        requestAnimationFrame(() => {
            updateActiveDot();
        });
    };

    // Update active dot style
    const updateActiveDot = () => {
        dots.forEach((dot, idx) => {
            if (idx === currentIndex) {
                dot.classList.add("bg-white", "scale-125");
                dot.classList.remove("bg-white/50");
            } else {
                dot.classList.remove("bg-white", "scale-125");
                dot.classList.add("bg-white/50");
            }
        });
    };

    // Auto advance
    const startAutoSlide = () => {
        stopAutoSlide(); // Clear existing to prevent duplicates
        intervalId = setInterval(() => {
            scrollToSlide(currentIndex + 1);
        }, 6000);
    };

    const stopAutoSlide = () => {
        if (intervalId) clearInterval(intervalId);
    };

    // Event Listeners
    if (prevBtn) {
        prevBtn.addEventListener("click", () => {
            stopAutoSlide();
            scrollToSlide(currentIndex - 1);
            startAutoSlide();
        });
    }

    if (nextBtn) {
        nextBtn.addEventListener("click", () => {
            stopAutoSlide();
            scrollToSlide(currentIndex + 1);
            startAutoSlide();
        });
    }

    // Manual navigation via dots
    dots.forEach((dot) => {
        dot.addEventListener("click", (e) => {
            e.preventDefault(); // Prevent default anchor jump
            stopAutoSlide();
            const index = parseInt((dot as HTMLElement).dataset.index || "0");
            scrollToSlide(index);
            startAutoSlide();
        });
    });

    // Detect manual scroll (touch/swipe) to update index
    if (slider) {
        let isScrolling: any;
        slider.addEventListener("scroll", () => {
            window.clearTimeout(isScrolling);
            isScrolling = setTimeout(() => {
                // Read layout properties
                const scrollLeft = slider.scrollLeft;
                const width = cachedSliderWidth || slider.clientWidth;
                currentIndex = Math.round(scrollLeft / width);
                
                // Batch DOM writes in next frame
                requestAnimationFrame(() => {
                    updateActiveDot();
                });
            }, 100); // Debounce
        }, { passive: true });

        // Pause on hover/touch
        slider.addEventListener("mouseenter", stopAutoSlide);
        slider.addEventListener("mouseleave", startAutoSlide);
        slider.addEventListener("touchstart", stopAutoSlide);
        slider.addEventListener("touchend", startAutoSlide);
    }

    // Initialize
    updateActiveDot();
    startAutoSlide();

    // Parallax Effect - Optimized to avoid forced reflows
    const parallaxSlides = document.querySelectorAll(".carousel-item");
    
    parallaxSlides.forEach((slide) => {
        const image = slide.querySelector("img") as HTMLImageElement;
        if (!image) return;

        // Cache bounding rect to avoid repeated layout reads
        let cachedRect: DOMRect | null = null;
        let rafId: number | null = null;

        // Update cached rect on resize/scroll (debounced)
        const updateRect = () => {
            cachedRect = slide.getBoundingClientRect();
        };

        // Initial rect calculation
        updateRect();

        // Update rect on window resize (debounced)
        let resizeTimeout: any;
        window.addEventListener("resize", () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(updateRect, 100);
        }, { passive: true });

        slide.addEventListener("mousemove", (e) => {
            const evt = e as MouseEvent;
            
            // Use cached rect to avoid layout thrashing
            if (!cachedRect) return;
            
            // Cancel previous frame if still pending
            if (rafId) cancelAnimationFrame(rafId);
            
            // Batch the style write in the next animation frame
            rafId = requestAnimationFrame(() => {
                const { left, top, width, height } = cachedRect!;
                
                // Calculate mouse position relative to center (-0.5 to 0.5)
                const x = (evt.clientX - left) / width - 0.5;
                const y = (evt.clientY - top) / height - 0.5;

                // Move image opposite to mouse direction
                const moveX = x * -20; 
                const moveY = y * -20;

                image.style.transform = `scale(1.1) translate(${moveX}px, ${moveY}px)`;
                rafId = null;
            });
        }, { passive: true });

        // Reset on leave
        slide.addEventListener("mouseleave", () => {
            if (rafId) cancelAnimationFrame(rafId);
            rafId = requestAnimationFrame(() => {
                image.style.transform = "scale(1.1) translate(0px, 0px)";
                rafId = null;
            });
        }, { passive: true });

        // Update rect when slide comes into view
        slide.addEventListener("mouseenter", updateRect, { passive: true });
    });
</script>
